
Todo
==================================================
#####: Refactor/Redesign:
		Grammar.define ... end #=> Grammar
		RDParser.new(grammar) #=> Parser
		EarleyParser.new(grammar) #=> Parser

#   ?: ParseContext: column calculation: tab should add 4 columns
#### : Ugly: rule unary => ~plus >> int # plusses get removed which should not be



Error Detection & Handling:
---------------------------
###  : auto-detect synchronization-tokens for error recovery: a => '[' & ... & ']'
###  : On SyntaxError insert an error node in the AST tree
###  : error-rule: x => a | b | error("myerror")
###  : Error report, hooks and skipping incorrect tokens

Grammars:
---------
#    : Analyze grammar: potential ambiguities etc; style tips: +asd? => ~asd
#    : Use ruby-graphviz to output the Grammar: grammar.to_image('grammar')
#    : grammar.to_s #=> list rules and skippers
#    : Grammar.ambiguous? #=> Ternary: yes,no,unknown
###  : Grammar.nonterminals #=> list of rules
#    : Grammar.normalize(:cnf)

Grammy DSL:
-----------
###  : LexerState/Skipper changes: 
			a => '[' & lexer(:skip_newlines) & ... & ']' & lexer(:reset)
			a => '[' & ->{lexer.state = ...} & ... & ']' & ->{lexer.state = ...}
			a => '[' & push_skipper(:newlines) & ... & pop_skipper ']'
			a => '[' & using_skipper(:newlines)[ a >> b ] & ']'
###? : skipper s => ..., :only => [...], :except => [...]
?    : move helper methods into a module/class and access them like this:
		rule args => Helper.list(arg)
!    : Predicates seem only useful at the end of a rule
##   : Predicates: Positive and Negative Lookahead (read without consuming)
		negative: !x, -x
		positive:
			look(x)
			x.look
###  : Let multiple rules with same name define alternatives(rule a => 'x' | 'y'): 
		rule a => 'x'
		rule a => 'y'
#    : support exceptions: x => ('a'..'z')*3 - 'lol'
##   : give tokens a name/id for ast tree: ident.name, ident[:name]
		Named subnodes can then be accessed like this: ident.name, ident[:name]
		Unnamed subnodes have to be accessed like this: ident[:some_node]
#    : Make predefined parsers available (skippers,comments,...): use :string, :int, :float
##   : Alternative vs Prioritized Alternatives: '|' vs '/'

Performance:
------------
#    : Performance: maybe use first_set of rule for fast rejection/decision
#### : Performance: Regex is way faster than composite rules. try to convert composite rules to regex rules when possible.
###  : Benchmark: chars per second. Benchmark/Profile suit with ruby-prof?
#### : Performance analysis:
		- Count how often backtracks occur. 
		- Count how often each part in the stream is read.
###  : StreamReader/Lexer: marks parts as whitespace and does not read them again
###  : ParseContext: LineNumber calculation: precalculate indices of linebreaks

Abstract Syntax Tree:
---------------------
###  : list(rule) ast transformation: rule >> ~(',' >> rule) #=> array of ast nodes
##   : transformations: rule x => +digit, map: ->(node){ Integer(node.data) }
#    : AST Node naming & reordering: use '^', '<=>' ?
###  : rule x => y._ >> z
		merge the children of the ast node generated by y into the children of x.
		no node for y, only for its subnodes.
		Can be used to flatten the AST in some parts.
#### : rule x => y # should create a node named x with one child named y

Testing:
--------
###  : GrammySpec: SpecFramework for grammars: expectations for acceptance and generated AST
		- yaml file with match expectations: full/partial/no match
		- yaml file with error expectations: line, column
		- yaml file with AST expectations: names, data, structure
#    : Validate Grammar:
		- check for left recursion
		- check for never matching rules: ~a >> a #=> never matches, (a? | b?) #=> always matches first
		- nested token rules?


##   : automatically check for valid identifiers: insert identifiers into table and check identifiers against that table
##   : Skipper before and after token? only in sequence?
#    : Make constants accessible in grammar definition dsl
#    : Skipper class which wraps a rule
#    : Maybe use Aquarium for logging with AOP. Or for less dependencies: 
		Rule#match does logging, Rule#match_impl does the real matching


Done
==================================================
###  : optional rules: a >> [(',' >> a)+] # change [x,y] => alternative?, [x] => optional
###  : Match anything: a >> ~any >> b #=> use regex rule: /./
##   : determine the first-set for rules
#    : nice to have: 1..9 instead of '1'..'9'
##   : support Regexp as rules
#### : replace symbols with method calls in the DSL: rule x => +letter >> '.'
##   : Rule.to_s #=> (a >> b) | c # see: Rule#to_s and Rule#to_bnf
###  : list helper should use & because after a seperator alwasy comes an item.
###  : support multiple skippers and ability to chose individual skipper for each rule.
##   : Add Rule-Option 'debug' (Bool). Anonymous rules should have debug=false and named rules debug = true
###  : callback 'modify_ast': modify_ast: lambda{|node| ... and return node }
#### : new names for rule options: merging_nodes, generating_ast, using_skipper
#### : pass options to rule: rule a: 'a', helper: true, skipping: false
##   : Custom rspec matchers: should fully_match('a','b',...) etc in spec/support
###  : Optional rules should only generate ast node when they match something.
##   : Error recognition/handling: disallow backtracking: '&' instead of '>>'
##   : track linenumbers for error report and compilation (semantic action?)
#### : ParserContext: stores line number, current line, head position, stream, symbol table, etc
##   : Seperate files for rules
###  : Add Rule#parent and Rule#root
###  : fragment = no skipping + helper
###  : Make name for a grammar optional: g = Grammy.define do ... end
###  : Use ruby-graphviz to output the AST: ast.to_image('ast')
#### : zero or more x: ~x
##   : Turn debugging on and off? grammar.parse("...", debug: true)
##   : EOS parser
#### : Ignore/skip parser: whitespaces & comments
##   : Make DSL removable: alias_method, remove_method etc
#### : one or more: +x
#### : optional rules: :identifier?
###  : Add logger and convert puts to debug messages
##   : Shortcut for: a >> (',' >> a)*;
		- a % ','
		- a / ','
		- list(a,',') or list?(a,',') #=> chosen list(a,',')

Dropped
==================================================

