
require 'spec/spec_helper'

describe "AST should" do

	describe "merge nodes generated by" do

		it "a constant repetition rule" do
			g = Grammy.define do
				helper lower: 'a'..'z'
				start string: :lower * 4
			end

			g.parse("some").tree.should have_properties(
				:data => 'some',
				:to_tree_string => "string{'some'}\n",
				:leaf_node? => true
			)
		end

		it "a +repetition rule" do
			g = Grammy.define do
				helper lower: 'a'..'z'
				start string: +:lower
			end

			g.parse("somelongerstring").tree.should have_properties(
				:data => "somelongerstring",
				:to_tree_string => "string{'somelongerstring'}\n",
				:leaf_node? => true
			)
		end

		it "nested rules" do
			g = Grammy.define do
				helper lower: 'a'..'z'
				helper two_char: :lower >> :lower
				start string: +:two_char
			end

			g.parse("aabbccdd").tree.should have_properties(
				:data => "aabbccdd",
				:to_tree_string => "string{'aabbccdd'}\n",
				:leaf_node? => true
			)
		end

		it "a sequence rule" do
			g = Grammy.define do
				helper lower: 'a'..'z'
				start string: :lower >> :lower >> :lower >> :lower
			end

			g.parse("some").tree.should have_properties(
				:data => "some",
				:range => [0,4],
				:to_tree_string => "string{'some'}\n",
				:leaf_node? => true
			)
		end

		it "a sequence containing a constant repetition" do
			g = Grammy.define do
				helper lower: 'a'..'z'
				start string: :lower*3 >> :lower
			end

			g.parse("some").tree.should have_properties(
				:data => "some",
				:range => [0,4]
			)
		end

		it "a complex grammar" do
			g = Grammy.define do
				helper lower: 'a'..'z'
				helper upper: 'A'..'Z'
				helper letter: :lower | :upper
				helper ident_start: :letter | '_';
				helper ident_letter: :ident_start | ('0'..'9')
				start ident: :ident_start >> ~:ident_letter
			end

			g.parse("some__098_ID123").tree.should have_properties(
				:data => "some__098_ID123",
				:to_tree_string => "ident{'some__098_ID123'}\n",
				:leaf_node? => true
			)
		end

	end

	it "should only remove helper nodes" do
		g = Grammy.define do
			rule id: +('a'..'z')
			helper part: :id >> ':' >> :id
			rule sent: :part >> '.'
			start start: :sent*(1..3)
		end

		tree = g.parse("ab:ac.kk:ee.").tree

		tree.data.should == "ab:ac.kk:ee."

		tree.should have(2).children
		sent1 = tree.children[0]
		sent2 = tree.children[1]

		sent1.name.should == :sent
		sent2.name.should == :sent
		sent1.data.should == "ab:ac."
		sent2.data.should == "kk:ee."

		sent1.children.map{|c| {c.name => c.data}}.should == [{id: 'ab'}, {id: 'ac'}]
		sent2.children.map{|c| {c.name => c.data}}.should == [{id: 'kk'}, {id: 'ee'}]
	end

	it "should parse sequence grammar with skipper and not create nodes for skipper" do
		g = Grammy.define do
			default_skipper whitespace: +(' ' | "\n" | "\t")

			token a: 'ab'
			start start: :a >> :a >> :a
		end

		root = g.parse("ab\nab\t  ab").tree

		root.data.should == "ab\nab\t  ab"
		root.name.should == :start
		root.should have(3).children
		root.children[0].name.should == :a
		root.children[0].data.should == 'ab'
	end

	it "should parse sequence grammar with skipper and create nodes for tokens" do
		g = Grammy.define do
			default_skipper whitespace: +(' ' | "\n" | "\t")

			token a: 'ab' | 'xy'
			start start: :a >> :a >> :a
		end

		root = g.parse("ab\nxy\t  ab").tree

		root.data.should == "ab\nxy\t  ab"
		root.name.should == :start
		root.should have(3).children
		root.children[0].name.should == :a
		root.children[0].data.should == 'ab'
		root.children[1].name.should == :a
		root.children[1].data.should == 'xy'
	end

	it "generate only one node for complex tokens" do
		g = Grammy.define do
			token str: 'A' >> +('x' | 'y')
			start start: '-' >> :str >> '.'
		end

		start = g.rules[:start]
		start.should_not be_merging_nodes
		start.children[0].should be_merging_nodes
		start.children[0].should be_generating_ast

		start.children[2].should be_merging_nodes
		start.children[2].should be_generating_ast

		str = g.rules[:str]
		str.should_not be_merging_nodes
		str.children[0].should be_merging_nodes
		str.children[1].should be_merging_nodes
		rep = str.children[1]
		rep.children[0].should be_merging_nodes

		g.parse("-Ayyxyx.").should be_full_match
		g.parse("-Ayyxyx.").tree.to_tree_string.gsub(/[\n ]/,'').should == "start{str{'Ayyxyx'}}"
	end
end